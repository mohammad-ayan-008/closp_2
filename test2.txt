        return;

 Unary {
    token: Dereference,
    exp: Unary {
      token: Dereference,
      exp: Identifier(
       "c",
      ),
    },
  },



// fn int somefn(int a){
//
//   int a = 10;
//   int b = a -1;
//   a = a-5;
//   char a = 'a';
//   int* ptr =  &b;
//   printf("%d",*ptr);
//   char* name = "hello";
//   printf("%s \n",name);
//
//   {
//     int ck = 6;
//     printf("value is %d \n",ck);
//   }
//   return 1;
// }
//


fn int test(int a){

  return 5;
}

fn void swap(int* a,int* b){
   int temp = *a;
   *a = *b;
   *b = temp;
}


fn int main(int a,int b,){

    int a = 5;
    int* b = &a;
    void* name = (void*) "hello world";
    Str* name = "lol world";
    bool b = true;

   {
     *a = 6;
     a = 6;
     test(1);
   }

   main((int*)1==1);
   test(123);
   return (int) (void*) (5+1/2);
}



Expression::Unary { token, exp } => {
    match token {
        expressions::UnaryOP::Adressof => {
            // Compute address-of recursively
            let mut current_exp = exp.as_ref();
            loop {
                match current_exp {
                    // Handle nested & (like &&x)
                    Expression::Unary {
                        token: expressions::UnaryOP::Adressof,
                        exp: inner,
                    } => {
                        current_exp = inner;
                    }
                    Expression::Identifier(ident) => {
                        // Look up the variable in scope
                        let (ptr, _logical_type, _stored_type, _cached_value) =
                            self.look_up(ident).unwrap();

                        // Return the pointer (i.e., address of the variable)
                        return Ok(ptr.as_basic_value_enum());
                    }
                    _ => panic!("Expected identifier after &"),
                }
            }
        }

        expressions::UnaryOP::Dereference => {
            // Dereference recursively
            let mut current_expr = exp.as_ref();

            loop {
                match current_expr {
                    // Handle nested * (like **p)
                    Expression::Unary {
                        token: expressions::UnaryOP::Dereference,
                        exp: inner,
                    } => {
                        current_expr = inner;
                    }
                    Expression::Identifier(ident) => {
                        // Look up the variable
                        let (mut ptr, mut ty, stored_type, _) = self.look_up(ident).unwrap();

                        // Load the value from the pointer
                        let mut val = self.builder.build_load(stored_type, ptr, "load_ptr").unwrap();

                        // Keep dereferencing while type is a pointer
                        while let Type::Pointer(inner_ty) = ty {
                            let llvm_inner_ty = self.llvm_type(&inner_ty).unwrap();
                            val = self.builder
                                .build_load(llvm_inner_ty, val.into_pointer_value(), "deref_val")
                                .unwrap();
                            ty = *inner_ty; // update type for next iteration
                        }

                        return Ok(val);
                    }
                    _ => panic!("Expected identifier after *"),
                }
            }
        }

        _ => panic!("Unhandled unary operator"),
    }
}
fn bool comparitor(int* a,int* b){
  if (*a == *b){
    return true;
  }else {
    return false;
  }
  printf("compared\n");
  return false;
}

fn int fiboiter(int n){
  if (n==0){
    return 0;
  }
  if (n==1){
    return 1;
  }
  int a = 0;
  int b = 1;
  int next = 0;
  int i =2;

  while (i<= n){
    next = a +b;
    a = b;
    b = next;
    i++;
  }
  return b;
}

fn void swap(int* a,int* b){
  int temp = *a;
  *a = *b;
  *b = temp;
}

fn void loopdata(int data){
  int a =0;
  while (data != a){
    printf("%d\n",a);
    a++;
  }
}

fn int fibo(int num){
  if (num <=1){
    return num;
  } 
  return fibo(num-1) + fibo(num-2);
}
fn void println(int** a){
  printf("%d\n",**a);
}

fn int main(){  
  printf("fibo is %d\n",fibo(9));
  printf("fibo is %d\n",fiboiter(9));

  loopdata(6);
  int l = 7;
  int k = 7;
  
  if (comparitor(&k,&l)){
    printf("true \n");
  }else{
    printf("false\n");
  }
 

  int num1 = 6;
  int num2 = 7;

  printf("before swap %d , %d\n",num1,num2);
  swap(&num1,&num2);
  printf("after swap %d , %d\n",num1,num2);

  int a = 6;
  int k = 9;
  int b = a++;
  int kl = a+k+a;
  printf("kl --->< %d",kl);
  printf("value after inc %d %d\n",b,a);
  printf("%d\n",a++);
  int jk = 10;   
  printf("kj ->>> %d\n",++jk);
  printf("kj ->>> %d\n",jk++);
  printf("kj ->>> %d\n",jk--);
  printf("kj ->>> %d\n",jk);
  printf("kj ->>> %d\n",--jk);
  printf("kj ->>> %d\n",jk);
  int* b = &a;
  int* j = &k;

  int** ck = &b;
  int** mf = &j;
  println(mf);
  return 0;
}

